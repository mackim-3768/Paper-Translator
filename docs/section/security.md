# 보안 및 프라이버시 리스크

이 문서는 논문 번역 서비스의 **보안 및 프라이버시 요구사항**을 정리합니다. 특히

- 인증/인가 전략 (`/upload`, `/status`, `/download` 보호)
- job_id 기반 접근 제어 및 소유권 개념
- 원본/번역 데이터 보관·삭제·로그 정책
- 전송/저장 시 데이터 보호
- PDF 파서/렌더러 관련 보안 업데이트 및 샌드박싱
- 시크릿/설정 관리 전략

을 다룹니다.

---

## 1. 보안 목표 및 범위

### 1.1 보안 목표

- **무단 접근 방지**
  - 인증되지 않은 사용자가 논문 파일이나 번역본에 접근하지 못하도록 함.
- **프라이버시 보호**
  - 업로드된 논문(원본/번역)에 포함된 민감 정보가 노출되지 않도록 함.
- **무결성 보장**
  - 번역 과정에서 데이터가 임의로 변조되거나 손상되지 않도록 함.

### 1.2 범위

- API 레이어 (`/upload`, `/status`, `/download` 등)
- 백엔드 서비스 (Job 처리, LLM 호출, PDF 파싱/렌더링)
- 스토리지(원본/번역 파일) 및 로그 저장소

---

## 2. 인증(Authentication) 및 인가(Authorization)

### 2.1 접근 정책 개요

- 외부에서 접근 가능한 모든 API는 **일종의 인증 토큰**을 요구하는 것을 기본 정책으로 합니다.
  - v1에서는 간단한 **API Key/Header 기반 토큰**도 가능.
  - 이후 사용자 계정 기반 서비스로 확장 시 **JWT/OAuth2** 전략 도입.

### 2.2 엔드포인트별 요구사항

- `POST /upload`
  - 인증된 클라이언트만 호출 가능.
  - Rate Limit 및 파일 크기 제한 정책과 연계.

- `GET /status/{job_id}`
  - 인증 필수.
  - 요청한 주체가 해당 `job_id`의 소유자인지 검사(3장 참조).

- `GET /download/{job_id}`
  - 인증 필수.
  - Job 소유자 검사를 반드시 통과해야 함.

### 2.3 구현 방향 (예시)

- v1 단순 토큰 방식
  - 요청 헤더 `X-API-Key: <token>` 기반.
  - 서버 측에서 유효 토큰 목록을 저장(예: DB/Redis)하고, 각 토큰을 하나의 `owner`(또는 `client`)로 간주.

- 확장 시 JWT/OAuth2
  - `sub` 클레임을 `user_id` 또는 `client_id`로 사용.
  - 토큰 만료/갱신 정책을 별도 인증 서버에서 관리.

---

## 3. Job 소유권 및 접근 제어

### 3.1 Job과 Owner 매핑

- Job 엔티티는 생성 시점에 **소유자 정보**를 함께 기록합니다.
  - 예: `owner_id: string` (API Key 또는 사용자 ID)

- 규칙
  - `upload`를 호출한 주체의 `owner_id`를 Job에 저장.
  - 이후 `status`/`download` 호출 시, 요청 주체의 `owner_id`와 Job의 `owner_id`가 일치해야 합니다.

### 3.2 job_id 보호

- `job_id`는 UUID 등 충분히 추측이 어려운 값으로 생성합니다.
- 그럼에도 불구하고, 단순 `job_id` 추측 공격에만 의존하지 않고 **반드시 owner 검증**을 수행해야 합니다.

### 3.3 브루트포스/대입 공격 방지

- `/status/{job_id}`, `/download/{job_id}` 호출에 대해
  - IP/owner 단위 Rate Limit 적용.
  - 존재하지 않는 `job_id`에 대한 반복 요청이 일정 횟수를 넘을 경우 일시 차단/알림.

---

## 4. 데이터 보관·삭제·로그 정책

### 4.1 데이터 종류 구분

- **원본 데이터**: 업로드된 논문 PDF.
- **번역 데이터**: 번역된 PDF 및 중간 텍스트/문서 구조.
- **메타데이터**: Job 상태, 생성 시각, 페이지 수 등.
- **로그 데이터**: 요청/응답 메타 정보, 에러 코드, 스택 트레이스 등.

### 4.2 보관 기간 정책

- 원본/번역 PDF
  - 기본 보관 기간: 예) **7일**.
  - `expires_at` 이후에는 백그라운드 작업에 의해 삭제.

- 메타데이터
  - 운영/통계 목적 상 더 긴 기간 보관 가능 (예: 수개월).
  - 단, 개인 식별 가능 정보가 포함되지 않도록 설계.

### 4.3 삭제 정책

- 만료에 따른 자동 삭제 외에도, 향후 사용자 요청에 따른 **수동 삭제 API**를 고려합니다.
  - 예: `DELETE /jobs/{job_id}` — 해당 Job의 원본/번역 파일 및 관련 로그 일부 삭제.

### 4.4 로그 정책

- **로그에 원문/번역 텍스트를 기록하지 않습니다.**
  - 텍스트 내용은 프라이버시/저작권 위험이 높으므로, 최대한 저장하지 않음.

- 로그에는 다음 정보를 중심으로 남깁니다.
  - Job ID, owner_id, 상태 전이, 에러 코드, 처리 시간, 요청 경로, HTTP 상태 코드 등.

---

## 5. 전송 및 저장 시 보안

### 5.1 전송 구간(Transit) 보안

- 클라이언트 ↔ 서버 간
  - HTTPS/TLS를 전제로 하며, HTTP 평문 통신은 허용하지 않습니다.

- 서버 ↔ 외부 LLM API 간
  - LLM 제공자의 HTTPS 엔드포인트만 사용.
  - 네트워크 레벨에서 LLM API 도메인에 대한 아웃바운드만 허용하는 방화벽/보안 그룹 설정을 고려.

### 5.2 저장 구간(At Rest) 보안

- 스토리지(로컬 디스크/S3 등)에 저장되는 파일은
  - 인프라 수준 암호화(디스크 암호화, S3 SSE 등)를 활용.

- 민감 정보가 포함될 가능성이 있는 메타데이터 컬럼은 필요 시 애플리케이션 레벨에서 추가 암호화 고려.

---

## 6. PDF 파서/렌더러 보안 및 샌드박싱

### 6.1 라이브러리 관리

- PyMuPDF, WeasyPrint, ReportLab 등은 **보안 업데이트 이력**이 있는 라이브러리이므로,
  - 버전 고정(핀) 후 정기적으로 최신 보안 패치 적용 여부를 점검.

### 6.2 샌드박싱 전략

- PDF 파싱/렌더링은 잠재적으로 악성 PDF에 노출될 수 있으므로,
  - 별도 컨테이너/워크 프로세스에서 수행하는 것을 기본 전략으로 합니다.
  - 이 컨테이너/프로세스에는 최소 권한 원칙 적용 (파일 시스템/네트워크 접근 제한).

### 6.3 외부 리소스 로딩 차단

- HTML 기반 렌더링(WeasyPrint 등)을 사용할 경우
  - 외부 URL을 임의로 로드하지 않도록 설정.
  - 템플릿/스타일시트는 내부 리소스로만 구성.

---

## 7. 시크릿 및 설정 관리

### 7.1 시크릿 종류

- OpenAI 등 LLM API Key
- 데이터베이스/RabbitMQ/스토리지 접속 정보
- 내부 관리용 토큰/서명 키 등

### 7.2 관리 원칙

- 코드 레포지터리 내에 **시크릿을 하드코딩하지 않습니다.**
- 모든 시크릿은 환경 변수 또는 전용 시크릿 관리 도구(예: AWS Secrets Manager, HashiCorp Vault 등)를 통해 관리합니다.
- 시크릿 변경/회전(rotaion)이 용이하도록 설정 구조를 단순하게 유지합니다.

---

## 8. 요약

- 본 문서는 논문 번역 서비스의 보안/프라이버시 관점에서
  - 인증/인가,
  - Job 소유권 및 접근 제어,
  - 데이터 보관/삭제/로그 정책,
  - 전송/저장 구간 보안,
  - PDF 파서/렌더러 샌드박싱,
  - 시크릿/설정 관리
  를 정의했습니다.

이 정의를 기반으로, 실제 구현 시 보안 요구사항을 체계적으로 반영하는 것을 목표로 합니다.
